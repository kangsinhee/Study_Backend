## 객체지향 프로그래밍(OOP)

### 요약 정리

- **OOP**
  - 객체들이 서로 유기적으로 동작하는 프로그래밍 이론
  - 코드의 재사용성과 중복제거가 가장 큰 목적

1. **추상화**
   * 목적과 관련이 없는 부분을 제외해서 필요한 부분을 포착하는 기법
   * 객체의 공통된 속성들 중 필요한 부분을 포장해서 클래스로 정의하는 설계 기법
2. **캡슐화**
   * 외부에 노출할 필요가 없는 정보들은 은닉 (정보은닉)

3. **상속**
   * 상속 관계에 있는 두 클래스에 대해, 부모 클래스가 자손 클래스에게 속성을 물려주는 것
   * 코드의 재사용이 목적

4. **다형성**
   * 같은 형태이지만 다른 기능을 하는 것
   * 오버라이딩은 이와 관련된 기능임

---

### OOP의 기본 구성 요소

#### OOP?

**OOP** 즉 **객체지향 프로그래밍**이란
컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나
여러 개의 독립된 단위, 즉 **객체들의 모임**으로 파악하고자 하는 것,
객체의 관점에서 프로그래밍하는 것을 의미함

*사람이 말로 표현 가능한 모든 것을 객체라 할수 있음*

**장점**

프로그램을 유연하고 변경이 유연하게 만듬

+ 대규모 소프트웨어 개발에 많이 사용함
+ 소프트웨어 개발과 보수를 간편하고 직관적이게 코드 분석을 가능하게 함

#### 요소

* 클래스(Class)

  * **객체를 만들어 내기 위한 설계도 or 틀**
  * 같은 종류의 집단에 속하는 속성과 행위를 정의한 것, 다른 클래스와 독립적으로 디자인해야 함. 구현할 현실의 물체의 특성과 행위를 정의한 객체가 클래스가 됨.
  * 연관되어 있는 변수와 메서드의 집합

* 객체(Object)

  * 개념
    * **구현할 대상**
    * 클래스의 인스턴스. 상위 클래스의 속성을 가지고 있으면서 개별적인 특성과 행위 또한 가지고 있음
    * 클래스에 선언된 모양 그대로 생성된 실체
  * 특징
    * 클래스의 **인스턴스**라고도 함
    * 객체는 모든 인스턴스를 대표하는 포괄저긴 의미를 갖음

* 인스턴스(Instance)

  * 개념

    * 클래스를 바탕으로 소프트웨어 세계에 구현된 **실체**
    * 실체화된 인스턴스는 메모리에 할당됨

  * 특징

    * 인스턴스는 객체에 포함된다고 볼 수 있음
    * oop의 관점에서 객체가 메모리에 할당되어 실제 사용될 때 **인스턴스**라고 불림
    * 추상적인 개념과 구체적인 객체 사이의 관계에 초점을 맞출때 사용함

    *인스턴스는 어떠한 원본(추상적)으로부터 생성된 복제본을 의미함*



---

### 특징

#### 추상화

> 어떤 영역에서 필요를 하는 속성이나 행동을 추출하는 작업

* 사물들의 공통된 특징, 즉 추상적 특징을 파악해 인식의 대상으로 삼는 행위를 말함
* 구체적인 사물들의 공통저긴 특징을 파악해서 이를 하나의 개념(집합)으로 다루는 수단을 말함

각 개체의 구체적인 개념에 의존하지 말고 추상적 개념에 의존래야 설계를 유연하게 변경할 수 있다.

**구체적인 개념에 의존하는 경우**

```kotlin
when(과일 종류) {
    "apple" -> //사과박스에 담음
    "pineapple" -> //파인애플 박스에 담음
    "kiwi" -> //키위박스에 담음
    ...
```

**추상적인 개념에 의존하는 경우**

```kotlin
fun wrappingFruit(fruit: String): unit{
    fruit.wrappingFruit()
}
```

* `wrappingFruit`의 인자로 `apple`, `kiwi`등의 추상화 개념인 fruit을 사용함
* *이 코드는 어떤 과일을 넣어도 변경할 필요가 없음*
* *뒤에서 다룰 "다형성"의 원리에 따라 각 클래스에서 오버라이드 된 메서드를 호출함*

#### 캡슐화

> **하나의 객체에 대해 그 객체가 특정한 목적을 위한**
> **필요한 변수나 메소드를 하나로 묶는 것을 의미함**

높은 응집도와 낮은 결합도를 유지할 수 있도록 설계해야 요구 사항을 변경할 때 유연하게 대처할 수 있음

1. 응집도(Conhesion)
   * 클래스나 모듈안의 요소들이 얼마나 밀접하게 연결되어 있는지를 나타냄
2. 결합도(Coupling)
   + 어떤 기능을 실행하는 데 다른 클래스나 모듈들에 얼마나 의존적인지를 나타냄

* **정보은닉**

  캡슐화를 하는 중요한 목적은 바로 정보은닉이다. 유저 정보를 가지고 있는 User라는 객체에서 유저의 정보가 public이라면 누구든 접근해서 유저 정보를 변경할 수 있다. 그렇기 때문에 private로 해서 데이터 접근을 제한해야 함

> 캡슐화와 정보은닉은 동일한 개념이 아님
> 캡슐화를 하면 불필요한 정보를 감출 수 있기 때문에 정보은닉을 할 수 있다는 특징이 있다는 것.

#### 다형성

다형성은 상속을 통해 기능을 확장하거나 변경하는 것을 가능하게 해줌

> 다형성은 **형태가 같은데 다른 기능을 하는 것을 의미함**
> (같은 동작 다른 결과) 

이를 통해 코드의 재사용, 코드 길이 감소 등 유지보수가 용이하도록 도와줌

**Overriding & OverLoading**

OOP에서 다형성의 개념을 녹여내는 방법은 두가지인데, 바로 **오버라이딩(Overvviding)**과 **오버로딩(OverLoading)**임 

* Overriding
  * 부모 클래스에서 상속받은 자식 클래스에서 부모클래스에서 만들어진 메서드를 자식클래스에서 다시 재정의해서 사용하는 것을 말함
* OverLoading
  * 같은 이름의 메서드를 사용하지만 메서드마다 다른 용도로 사용되며 그 결과물도 다르게 구현할 수 있게 만드는 개념
  * 메서드 이름이 같아도 문법 에러 X

```kotlin
//overriding
open class Employee {
    var name: String
    var age: Int
    
    fun print() {
        println("사원의 이름 $name, 나이 $age")
    }
}
//Employee 상속
class Manager: Employee() {
    var jobOfManege: String
    
    //Employee의 print 메소드 오버라이딩
    override fun print() {
        println("사원의 이름 $name, 나이 $age")
        println("관리자 $name은 $jobOfManager 담당입니다.")
    }
}

//Overload
class OverloadTest {
    fun test() {
        println("사용자 없음")
    }
    fun test(name: String) {
        println("사용자 이름: $name")
    }
    fun test(name: String, age: Int) {
        println()
    }
}
```

##### 장점

같은 이름의 속성을 유지함으로서, 속성을 사용하기 위한 인터페이스를 유지하고 메서드 이름을 낭비하지 않음

*API가 많아질수록 복잡성은 증가하기 때문에 다형성이 유용함*

#### 상속성

코드의 중복이 많아지면 개발단계에서도  피곤하지만 유지보수에서도 많은 비용이 들게 됨`코드의 이원화 문제`

OOP에서 상속을 통해 코드의 중복 문제를 해결할 수 있음
