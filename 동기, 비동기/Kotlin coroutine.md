## Kotlin, Coroutine

Kotlin 코루틴은 비동기 코드를 작성할 수 있게 하는 API를 제공하며,
코루틴이 실행되어야 하는 시기를 관리하는 데 도움이 되는 CoroutineScope를 정의할 수 있음

### Conroutine?

Countine은 백그라운드 스레드에서 코드를 처리하는 비동기 작업을 사용하는 방법 중 하나임
Kotlin의 하위 개념이 아닌, Python이나 Go, C# 등 다양한 언어에서도 지원하는 개념임

#### 협력형 멀티태스킹

협력형 멀티태스킹을 프로그래밍 언어로 표현하자면 Co + Routine라는 뜻으로 
Co라는 접두어는 "협력", "함께"라는 의미를 지니고 있음 Routine은 하나의 태스크, 함수 정도로 생각하면 됨. 
*즉 협력하는 함수*

Routine에는 흔히 알고 있는 main route과 sub routine이 있고, 이 Sub Routine에 진입 후 
아래 코드를 차례대로 모두 실행한 뒤 return문을 만나면, 탈출하게 됨 
진입점과 탈출점 사이에 쓰레드는 블락되었으며, 루틴에 진입하는 지점과 루팀을 빠져나오는 지점이 명확함

*Routine은 흔히 늘 짜게 되는 코드라고 이해하면 됨*

하지만 Co Routine도 routine이기 때문에 하나의 함수로 생각함. 
여기서 Coroutine은 이 함수에 진입할 수 있는 진입점과 언제든지 탈출할 수 있는 탈출점도 여러개임. 

즉 코루틴 함수는 꼭 return문이나 마지막 닫는 괄호를 만나지 않더라도 
언제든지 탈출하고, 탈출지점으로 다시 들어올수 있음

```kotlin
fun drawPerson() {
    //1
    //쓰레드의 main함수가 drawPerson()을 호출하면 하나의 코루틴 블럭이 생김
	//drawPerson()은 언제든 진입, 탈출할 수 있는 자격이 주어짐
    startCoroutine {
        //2
        //코루틴 함수가 실행되는 과정에서 suspend 키워드를 가진 함수를 만나게 되면
		//더이상 아래 코드를 실행하지 않고 코루틴 block을 탈출함
        drawHead()		
        //Head를 탈출하고 메인 쓰레드에 다른 코드가 실행됨(Head는 다른 프로세스에서 계속 실행되고 있음)
        drawBody()
        drawLegs()
        //다른 코드들이 실행되도 drawHead가 끝나면 다시 코루틴으로 진입해 아까 멈춘부분부터 실행됨
    }
}

suspend fun drawHead() {
    delay(2000)
    ...
}

suspend fun drawBody() {
    delay(2000)
    ...
}

suspend fun drawLegs() {
    delay(2000)
    ...
}
```

drawPerson이라는 함수가 있을 때, startCorountine 이라는 코루틴 빌더가 있음
*실제로 startCorountine이라는 빌더는 없음 실제와는 다른 방식으로 만들게 됨*

startCoroutine이라는 코루틴을 만나게 되면 해당 함수는 코루틴으로 작동될 수 있음
따라서 언제든지 쓰레드를 드나들수 있는 자격이 부여됨. 
이때 suspend로 선언된 함수를 만나면 코루틴 밖으로 나갈 수 있음

위 코드 주석으로 설명해 둔 것처럼 코루틴 함수는 언제든지 드나들수 있으며, 
코루틴의 이러한 성향은 동시성 프로그래밍과 밀접한 관계가 있음

#### 동시성 프로그래밍

함수를 중간에 빠져나왔다가, 다른 함수에 진입하고, 다시 원점으로 돌아와 
멈추었던 부분부터 다시 시작하는 이 특성은 **동시성 프로그래밍**을 가능하게 함

동시성 프로그래밍은 두 일에 대해 빠르게 번갈아 가며 처리해 동시에 처리하는 것처럼 보이는 것을 말함
병렬성 프로그래밍은 이와 반대로 실제로 두 일이 있다면 정말 동시에 처리하는 것을 말함 

이때 **코루틴**은 개념자체로만 보면 코루틴은 병렬성이 아닌 **동시성을 지원**하는 개념임

코루틴도 쓰레드가 아닌 일반 서브루틴과 비슷한 루틴이기 때문에 하나의 쓰레드에 여러개가 존재할 수 있음.

만약 쓰레드를 이용해 각각 두 작업을 처리하게 된다면 두 쓰레드를 매번 점유했다가 놓아주고를 반복해야 함
이를 **컨텍스트 스위칭**이라고 하며 굉장히 비용이 많이들며 비효율적임.

코루틴을 생성해서 동시성 프로그래밍을 하는 것은 쓰레드를 사용해서 
동시성을 처리하는 것과 차원이 다른 퍼포먼스를 보여줌.



#### 비동기처리가 굉장히 쉬움

```kotlin
suspend goSchool(person: Person) {
    val 잠든신희 = person
    try {
        val 점호받기1분전신희 = wakeUp(잠든신희)
        val 깨끗한신희 = takeShower(점호받기1분전신희)
        val 교복입은신희 = putOnShirt(깨끗한신희)
        val 아침점호받는신희 = finish(교복입은신희)
        
        아침받는신희.doStudy()
    } catch (e: Exception) {
        실패했을때()
    }
}
```

비동기 코드라고 믿기지 않을 정도로 다른 비동기 처리 방식과 비교하면 확연히 쉽고 간단하다고 할 수 있음
각각 언제 종료될지 모르는 비동기작업이지만 각자 함수들의 순서는 정확히 지켜짐

goSchool이라는 함수가 코루틴이기 때문에 wakeUp을 만나면 wakeUp함수를 실행함과 
동시에 잠시 goSchool을 빠져나가고, wakeUp이 끝마치면 돌아와 바로 다음 작업이 이어짐

결론적으로는 비동기처리에 있어서 Coroutine은 Rx나 다른 방법과 견줄 수 없을정도로 간편함.
비동기코드이지만 동기코드처럼 짤 수 있기 때문이라고 할 수 있음